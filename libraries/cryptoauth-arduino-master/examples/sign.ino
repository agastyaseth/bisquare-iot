#include <cryptoauth.h>

// This can only be run on a personalized AtECC108
AtEcc108 ecc = AtEcc108();

void
hexify(const char *str, const uint8_t *hex, unsigned int len)
{

  int i;

  Serial.write(str);

  Serial.write(" : ");

  for (i = 0; i < len; i++)
    {
      static char tmp[4] = {};
      if (i > 0)
        Serial.write(" ");

      sprintf(tmp, "0x%02X", hex[i]);
      Serial.write(tmp);
    }

  Serial.write("\n");

}

void setup() {
    Serial.begin(9600);
    ecc.enableDebug(&Serial);
}

void loop() {
    
    sha256_hash_t hash1;
    static uint8_t to_sign[] = {0x01, 0x02, 0x03};
    char sig[64];

    sha256(&hash1, to_sign, sizeof(to_sign));

    hexify("hash: ", &hash1[0], sizeof(hash1));

    if (0 != ecc.sign(&hash1[0], sizeof(hash1)))
        Serial.println("Fail sign");
    else
    {
      memcpy (sig, ecc.rsp.getPointer(), sizeof(sig));
      hexify("Signature:", (const uint8_t *) sig, sizeof(sig));

      /* NOTE: ECDSA P256 signatures are non-deterministic (in this
       * case), each time you sign something it will have a different
       * result! However, the hash will always be the same for the
       * same input. This is example output:


         hash:  : 0xE4 0xBB 0x11 0x94 0x04 0x69 0x40 0x74 0xEF 0xE5
         0x72 0x72 0x55 0x63 0x71 0x8F 0x13 0x9D 0x91 0xA5 0xEC 0x9A
         0x91 0x2C 0x63 0x16 0x23 0xEF 0x76 0x29 0x76 0xB8

         Signature: : 0xAC 0xC0 0xFE 0xE2 0x0C 0x79 0x79 0xBD 0xBD 0x71 0x64
         0x00 0x4B 0xE1 0x6F 0x8E 0xE6 0xD4 0xDF 0x3F 0x73 0x61 0x5E 0x1A 0xAD
         0x87 0xC4 0xFF 0xC3 0x91 0x07 0x1D 0x75 0x97 0x74 0x21 0x91 0xAB 0xAE
         0x33 0x7F 0x69 0xF4 0x71 0x8F 0x81 0xFD 0xD3 0xFC 0x83 0x21 0xC1 0x09
         0x44 0x97 0x20 0x17 0xE7 0x9F 0xE8 0x50 0x0D 0xD4 0x8A

      */

      
    }

    delay(5000);


}
